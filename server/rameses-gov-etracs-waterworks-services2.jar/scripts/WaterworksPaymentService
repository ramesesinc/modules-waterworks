import com.rameses.annotations.*;

class WaterworksPaymentService {


	@Service("DateService")
	def dateSvc;

	@Service("WaterworksBillingRuleService")
	def ruleSvc;


	@DataContext("waterworks_payment")
	def paymentEm;

	@DataContext("waterworks_billitem")
	def billItemEm;

	@DataContext("waterworks_credit")
	def creditEm;

	

	@DataContext("vw_waterworks_account")
	def vwAcctEm;

	@DataContext("vw_waterworks_bill")
	def vwBillEm;

	@ProxyMethod 
	public def postPayment( param ) {
		def rct = param;
		if(!rct.billitems) throw new Exception("Please include billitems");
		if(!rct.acctid ) throw new Exception("acctid is required");

		//post to the ledgers. discount should only be applied once
		def billitems = rct.billitems;
		billitems.each {
			if(it.discount == null) it.discount = 0;
			if(it.amount == null ) it.amount = 0;
			if(it.reftype == 'waterworks_billitem') {
				billItemEm.find( [objid: it.refid ]  ).update( [amtpaid: "{amtpaid + :amt}", discount: it.discount ] , [amt: it.amount]  );
			}
			else if( it.reftype == 'waterworks_credit' ) {
				//this is for overpayments and deposits
				def c = [:];
				c.acctid = rct.acctid;
				c.refid = rct.objid;
				c.refdate = rct.receiptdate;
				c.refno = rct.receiptno;
				c.reftype = "cashreceipt";
				c.dr = it.amount;
				c.cr = 0;
				c = creditEm.create( c );

				//this is for reference when voiding
				it.refid = c.objid;
			}
			else {
				throw new Exception("Waterworks post payment error! there must be a reftype in billitems");
			}
		}

		//post only at the last so the credit refid can be applied.
		def pmt = [:];
		pmt.txndate = dateSvc.getServerDate();;
		pmt.acctid = rct.acctid;
		pmt.refdate = rct.receiptdate;
		pmt.refno = rct.receiptno;
		pmt.reftype = "cashreceipt";
		pmt.refid = rct.objid;
		pmt.amount = rct.amount;
		pmt.voided = 0;
		pmt.txnmode = rct.txnmode;
		pmt.remarks = rct.remarks;
		pmt.pmttxntype = rct.pmttxntype;
		pmt.items = rct.billitems.collect{ [refid: it.refid, reftype:it.reftype, amount: it.amount, discount: it.discount, surcharge: it.surcharge, interest: it.interest, remarks: it.remarks]  };
		pmt.discount = pmt.items.sum{ it.discount==null ? 0 : it.discount };				
		if(rct.billid) pmt.billid = rct.billid;
		pmt.year = rct.year;
		pmt.month = rct.month;
		paymentEm.create( pmt );
	}

	@ProxyMethod 
	public def voidPayment( param ) {
		//check first if we can still void the transaction
		def pmt = paymentEm.find( [refid: param.receipt.objid  ]).first(1);
		if(!pmt) throw new Exception("payment not found");

		if(!pmt.items) throw new Exception("payment items not found!");

		pmt.items.each {
			if(it.reftype == "waterworks_billitem") {
				billItemEm.find( [objid: it.refid ] ).update( [amtpaid: "{amtpaid - :amt}", discount: 0 ], [amt: it.amount] );
			}
			else if( it.reftype == "waterworks_credit" ) {
				//remove tax credit from ledger
				creditEm.find( [objid: it.refid] ).delete();
			}
		}
		paymentEm.find( [objid: pmt.objid] ).update( [voided: 1 ] );
	}


	//called by capture payment in client
	@ProxyMethod
	public def getPaymentItems( def o ) {
		if(!o.acctid) throw new Exception("acctid is required in  WaterworksPaymentService.getPaymentItems");
		def pp = [:];
		pp.account = vwAcctEm.find( [objid: o.acctid ]).first();
		if(o.billid) o.billid = pp.account.billid;

		if(!o.billid) throw new Exception("billid is required in WaterworksPaymentService.getPaymentItems");
		pp.bill = vwBillEm.find( [objid: o.billid ]).first();

		pp.amtpaid = o.amtpaid;
		ruleSvc.getPaymentItems( pp );
	}


}