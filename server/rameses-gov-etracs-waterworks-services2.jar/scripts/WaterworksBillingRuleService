import com.rameses.annotations.*;
import com.rameses.util.*;
import waterworks.facts.*;
import treasury.utils.*;
import treasury.facts.*;

class WaterworksBillingRuleService {

	@Service("BillingRuleService")
	def ruleSvc;	

	@DataContext("vw_waterworks_account")
	def vwAcctEm;

	@DataContext("waterworks_billitem")
	def billItemEm;

 	@DataContext("waterworks_itemaccount")
	def itemAcctEm;

	private def buildFacts( def o, def billitems ) {
		def acct = o.account;
		def bill = o.bill;

		def facts = [];
		facts << new WaterAccount( acct );
		facts << new WaterBill( bill );
		acct.attributes.each {
			facts << new WaterworksAttribute( name: it );
		}
		billitems.each {
			def wbi = new WaterBillItem();
			wbi.objid = it.objid;
			wbi.refid = it.objid;
			wbi.year = it.year;
			wbi.month = it.month;
			wbi.billcode = it.item.objid;
			wbi.sortorder = it.item.sortorder;
			wbi.amount = it.amount - it.amtpaid - it.discount;
			//this was a workaround. If parentrefid equals acct.objid then make it null;
			if( it.parentrefid != acct.objid ) {
				wbi.parentrefid = it.parentrefid;
			}
			wbi.principal = it.amount;
			facts << wbi;	
		}
		def factBuilder = new FactBuilder();
		factBuilder.facts = facts;
		return factBuilder;
	}


	@ProxyMethod
	public def getBillItems( def o ) {
		def acct = o.account;
		def bill = o.bill;
		def ym = (bill.period.year*12)+bill.period.month;

		//these are called to calculate the surcharge. Include only items that have balances
		def pastItems = billItemEm.find( [acctid: acct.objid ] ).where("(amount-amtpaid-discount) > 0 AND ((year*12)+month) < :yearmonth", [yearmonth: ym]).list();

		//for current include all items for the bill whether paid or unpaid. This must be included so we can determine if we need to charge or not. avoid duplicates.
		def currItems = billItemEm.find( [billid:bill.objid] ).list();

		def fb = buildFacts( o, (pastItems + currItems) );
		def req = [rulename:'waterworksbilling'];
		req.factBuilder = fb;
		req.params = [objid:bill.objid];

		ruleSvc.execute(req);
		def items = [];
		fb.facts.findAll{ it instanceof WaterBillItem }.each {
			items << it.toMap();
		}
		def res = [:];
		res.billitems = items;
		return res;	
	}

	@ProxyMethod
	public def getPaymentItems( def o ) {
		def acct = o.account;
		def bill = o.bill;
		def amtpaid = o.amtpaid;
		def ym = (bill.period.year*12)+bill.period.month;

		def bitems = billItemEm.find( [acctid: acct.objid ] ).where("(amount-amtpaid-discount) > 0 AND ((year*12)+month) <= :yearmonth", [yearmonth: ym]).list();		
		def fb = buildFacts( o, bitems );

		def req = [rulename:'waterworkspayment'];
		req.factBuilder = fb;
		req.params = [amtpaid :  (o.amtpaid==null)? o : o.amtpaid ];
		if(o.include_items) req.include_items = o.include_items;

		ruleSvc.execute(req);

		def items = [];
		fb.facts.findAll{ it instanceof WaterBillItem }.each {
			def m = it.toMap();
			m.item = itemAcctEm.find( [objid: m.billcode ] ).first();
			m.reftype = "waterworks_billitem";
			items << m;
		}

		throw new Exception("find tomorrow the credit bill item");
		fb.facts.find{ it instanceof CreditBillItem }.each {

		}

		def cashitems = [];
		if(o.include_items == true ) {
			def grps = items.groupBy{ it.item.item };
			grps.each { k,v->
				def itm = [:];
				itm.item = k;
				itm.amount = v.sum{it.amount};
				
				def m1 = v.min{ it.yearmonth };
				def m2 = v.max{ it.yearmonth };
				itm.remarks = m1.monthname + " " + m1.year + " to " + m2.monthname + " " + m2.year; 
				cashreceiptitems << itm;
			}
		}
		def res = [:];
		res.billitems = items;
		res.items = cashitems;
		res.amount = cashitems.sum{ a.amount };
		return res;
	}


}