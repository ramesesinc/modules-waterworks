import com.rameses.annotations.*;
import com.rameses.functions.*;
import java.rmi.server.UID;
import com.rameses.util.*;
import treasury.utils.*;
import treasury.facts.*;
import waterworks.facts.*;
import com.rameses.annotations.*;
import com.rameses.util.*;


/****************************************************************************************
* Applicable for billing one item only.
* This is called on the ff. instances:
*   1. Batch billing - to get the arrears or overpayments if any
*   2. Cash Receipt - to display the receipts
*   3.  
*****************************************************************************************/

class WaterworksBillingRuleService {
	
	@DataContext('vw_waterworks_account')
	def acctEm; 


	@DataContext("vw_waterworks_consumption")
	def wcEm;

	@DataContext("waterworks_credit")
	def wcCreditEm;

	@DataContext("waterworks_otherfee")
	def wotherEm;

	@DataContext("waterworks_itemaccount")
	def itemAccountEm;

	@Service("BillingRuleService")
	def ruleSvc;	

	@Service("WaterworksScheduleService")
	def schedSvc;

	@DataContext("waterworks_billing")
	def billEm;

	def loadBillItems( o ) {

		def facts = [];
		def arr = [];
		def wp = [ state:'POSTED' ];
		if ( o.year!=null && o.month!=null ) { 
			arr << "((year * 12)+month) <= :yearmonth";
			wp.yearmonth = (o.year * 12)+o.month;
		} 
		def wheres = []; 
		wheres.addAll( arr ); 
		wheres << " state = :state AND hold=0 "; 
		wheres << " (amount - amtpaid - discount) > 0 ";

		def select = "hold,year,month,volume,amount:{amount-amtpaid-discount},";
		select += "principal:{amount},amtpaid,refid:{objid},reftype:{'waterworks_consumption'}";
		def conList = wcEm.find([acctid: o.acctid]).select(select).where(wheres.join(" AND "), wp).orderBy("year,month").list();

		def yearMonthList = [];
		def addYearMonth = { o->
			if( !yearMonthList.find{ it.year==o.year && it.month==o.month } ) {
				yearMonthList << [year:it.year, month:it.month];		
			}
		}

		conList.each {
			addYearMonth( it ); 
			facts << new WaterBillItem(it);
		}

		//select for other fees
		wheres = []; 
		wheres.addAll( arr );  
		wheres << "(amount - amtpaid - discount) > 0"; 
		select = "year,month,item.*,billcode:{item.objid},amount:{amount-amtpaid-discount},amtpaid,principal:{amount},refid:{objid},reftype:{'waterworks_otherfee'}";
		conList = wotherEm.find([acctid: o.acctid]).select(select).where(wheres.join(" AND "), wp).orderBy("year,month").list();

		conList.each {
			addYearMonth( it );
			facts << new MonthBillItem(it);
		}

		yearMonthList?.each {
			def sked = schedSvc.getSchedule( [ scheduleid: o.scheduleid, year:it.year, month: it.month ] );
			facts << new WaterBillingPeriod( sked );			
		}

		return facts;
	}

	@ProxyMethod
	public def getBilling( pp ) {
		if( !pp.acctid  ) throw new Exception("acctid is required in WaterworksBillingRuleService.getBilling");
		def acct = acctEm.find([ objid: pp.acctid ]).first();
		if(!acct) throw new Exception("Account not found");

		def scheduleid = acct.subarea.schedulegroupid;

		def pv = [year: pp.year, month: pp.month, acctid: acct.objid, scheduleid: scheduleid ];
		if( pp.request_action ) pv.request_action = pp.request_action;
		def billItemFacts = loadBillItems( pv );

		if(!billItemFacts && !pp.amtpaid ) {
			acct.items = [];
			acct.billitems = [];
			return acct;
		}

		def factBuilder = new FactBuilder();
		factBuilder.facts = billItemFacts; 
		factBuilder.facts << new WaterAccount( acct );

		//check if acct has arrears. This is to determine if we need to discount or not
		if( pp.billid ) {
			def bill = billEm.find( [objid: pp.billid ]).first();
			if(!bill) throw new Exception("Error in WaterworksBillingRuleService.getBilling. billid was specified but bill does not exist");
			factBuilder.facts << new WaterBilling( bill );
		}

		if( acct.attributes ) {
			acct.attributes.each {
				factBuilder.facts << new WaterworksAttribute(name:it);
			}
		}

		def req = [rulename:'waterworksbilling'];
		req.factBuilder = factBuilder;
		req.params = pp;
		if(pp.include_items) req.include_items = pp.remove("include_items");

		def res = ruleSvc.execute( req );
		res.putAll( acct );

		def itemMap = [:];
		def lookupItem = { pid->
			if( !itemMap.containsKey(pid)) {
				itemMap.put( pid, itemAccountEm.find( [objid: pid ] ).first() );
			}
			return itemMap.get(pid);
		}

		res.billitems?.each {
			if(it.billcode) it.item = lookupItem(it.billcode)?.item;
			if( it.txntype == "credit") {
				it.reftype = "waterworks_credit";
			}	
		}

		//attach the item accounts also
		if(res.items) {
			res.items.findAll{ !it.item?.objid}.each {
				it.item = lookupItem( it.billcode )?.item;
			}
			if(res.items.find{ !it.item?.objid }) 
				throw new Exception("All items must have an item account");
		}

		return  res;
	}

	
} 