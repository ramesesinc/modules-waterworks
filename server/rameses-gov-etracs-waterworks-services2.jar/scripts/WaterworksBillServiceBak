import com.rameses.annotations.*;

class WaterworksBillService {

	@Service("ControlnoGeneratorService")
    def controlNoSvc;

    @Service('Var')
	def var;

	@Service("WaterworksScheduleService")
	def skedSvc;

    @Service('DateService')
	def dateSvc;

	@Service("WaterworksBillingRuleService")
	def ruleSvc;

	@Service("WaterworksPaymentService")
	def pmtSvc;

	@DataContext("vw_waterworks_account")
	def vwAcctEm;

	@DataContext("vw_waterworks_bill")
	def vwBillEm;

	@DataContext("waterworks_bill")
	def billEm;

	@DataContext("waterworks_account")
	def acctEm;

	@DataContext("waterworks_billitem")
	def billItemEm;

	@DataContext("waterworks_payment")
	def pmtEm;

	@DataContext("waterworks_credit")
	def creditEm;

	public def getChecksum( def oldBill ) {
		def billid = oldBill.objid;	
		//calculate the checksum; theoretically this should be equal with bal forward
		def c = billItemEm.find( [billid: billid] ).select("total:{SUM(amount)}").val();
		if(c==null) c = 0;
		def d = pmtEm.find( [billid: billid ] ).select("total:{SUM(amount)}").val();
		if(d==null) d = 0;
		return oldBill.balanceforward  + c - d;
	}

	public def getBalanceForward(def o ) {
		def acctid = o.acctid;
		def ym = (o.year*12)+o.month;

		//this will return the a map that consists of the amount and the checksum amount of the bill and remarks if amount and checksum is correct
		//calculate the normal amt first
		def a =	billItemEm.find([acctid: acctid]).select("total:{SUM(amount-amtpaid-discount)}").where("(amount-amtpaid-discount)>0 AND ((year*12)+month)<= :yrmon", [yrmon: ym] ).val();
		if(a==null) a = 0;
		def b =	creditEm.find([acctid: acctid]).select("total:{SUM(dr-cr)}").where(" ((year*12)+month)<= :yrmon", [yrmon: ym] ).val();
		if(b==null) b = 0;
		return a - b;
	}

	@ProxyMethod
	public def getInfoForInitialBill(def o) {
		if(!o.acctid) throw new Exception("acctid is required in getInfoForInitialBill");	
		if(!o.year) throw new Exception("year is required in getInfoForInitialBill");	
		if(!o.month) throw new Exception("month is required in getInfoForInitialBill");	

		def acct = vwAcctEm.find( [objid:o.acctid] ).first();	
        def bill = [:];
        bill.period = skedSvc.getSchedule( [year: o.year, month: o.month, scheduleid:  acct.subarea.schedulegroup?.objid] );
        bill.balanceforward = getBalanceForward( [acctid: acct.objid, year: o.year, month: o.month ] );
		bill.details = [];
		bill.details << [particulars: "Balance Forward", amount: bill.balanceforward ];
		//load ledger items
		billItemEm.find([acctid: acct.objid] ).where( "year =:y AND month =:m", [y:o.year, m:o.month] ).list().each {
			def m = [particulars: it.item.title, amount: it.amount ];
			if( it.particulars ) m.particulars = m.particulars + " (" + it.particulars + ")";
			bill.details << m;
		};
		pmtEm.find( [acctid: acct.objid] ).where( "year =:y AND month =:m AND voided=0 AND reftype='cashreceipt' ", [y: o.year, m: o.month] ).list().each {
			bill.details << [ particulars: it.reftype + " Payment " + it.refno + " " + it.refdate, amount: (it.amount * -1) ]		
		}        
		bill.amount = bill.details.sum{ it.amount };

		return bill;
	}

	def getNextValidityDate(def period, def txndate ) {
		if(!txndate) txndate = dateSvc.getBasicServerDate();
		if( txndate.before( period.billdate ) ) {
			return period.billdate;	
		}
		else if( period.discdate && txndate.before(period.discdate )) {
			return period.discdate;		
		}
		else if( period.duedate && txndate.before(period.duedate)) {
			return period.duedate;
		}
		else {
			return period.billexpirydate;
		}
	}

	private void updateLedgerBillid( def p ) {
		billItemEm.find( [acctid: p.acctid, year: p.year, month: p.month ] ).update( [billid: p.billid ]);	
	}

	@ProxyMethod
	public def create( def o ) {
		def acctid = o.acctid;
		def txndate = o.txndate;
		if(!txndate) txndate = dateSvc.getBasicServerDate();	

		//this can be null
		def year = o.year;
		def month = o.month;

		def acct = vwAcctEm.find( [objid: acctid ] ).first();
		def balanceForward = 0;

		if( acct.billid ) {
			//find the previous bill. Close it 
			def oldBill = vwBillEm.find( [objid: acct.billid ]).first(); 

			if( (((oldBill.period.year*12)+oldBill.month)+1) != ((year*12)+month)  )
				throw new Exception("Error in year and month. Previous Bill is " + oldBill.period.year + " " + oldBill.period.monthname );		

			//close the old bill. This is done by specifiying oldBill.period.billexpirydate. The update bill also changes the state if it reaches expiry.
			if( oldBill.state != 'CLOSED' ) {
				update( [bill:oldBill, account: acct, txndate: oldBill.period.billexpirydate ] );
			}
			//calc the prev balance
			balanceForward = getBalanceForward( [acctid: acctid, year: oldBill.year, month: oldBill.month ] );
			//ignore the year and month specified. year and month should be null
			month = oldBill.month + 1;
			if(month > 12){
				month = 1;
				year = year + 1;
			}
		}

		def period = skedSvc.getSchedule( [scheduleid: acct.subarea.schedulegroupid, year: year, month: month ]  );
		def billno = o.billno;
		if(!billno) billno = o.billrefno;
		if(!billno) {
			def pattern = var.waterworks_billno_format;
			if(!pattern) throw new Exception("Please specify waterworks_billno_format in sys_var");
			billno = controlNoSvc.getNextNo(pattern);
		}

		//create the new bill
		def newBill = [:];
		newbill.billno = billno;
		newbill.billdate = txndate;
		newbill.acctid = acct.objid;
		newbill.billrefno = o.billrefno;
		newbill.acctinfoid = acct.acctinfoid;
		newbill.batchid = null;
		newbill.periodid = period.objid;
		newbill.period = period;
		newbill.expirydate = period.billexpirydate;
		newbill.state = "OPEN";
		newbill.balanceforward = balanceForward;
		newbill.billed = 0;
		newbill.refbillno = null;
		newbill.printed = 0;
		newbill.remarks = "";
		newbill.preparedby = [objid: env.USERID, fullname: env.FULLNAME ];
		newbill.validitydate =  getNextValidityDate( period, txndate );
		newbill = billEm.create( newbill );

		updateLedgerBillid( [acctid: acct.objid, year: period.year, month: period.month, billid: newbill.objid ] );

		//update the account only if there is an existing bill. Do not update for initial bills.
		if( acct.billid ) {
			throw new Exception("stop before billid");
			update( [bill: newbill, account: acct, txndate: txndate] );
		}
		else {
			//update the ledger 
		}
		throw new Exception("stop before save");
		acctEm.find([acctid: acctid ]).update([billid: newbill.objid ] );
		return newbill;
	}

	@ProxyMethod
	public void update( def o ) {
		def bill = o.bill;
		def acct = o.account;
		def txndate = o.txndate;

		throw new Exception("Error in update. Determine exact parameters here to pass to the rules");
		def res = ruleSvc.getBillItems( o );
		//this should add the new billitems
		res.billitems.findAll{it.objid!=null}.each { 
			def m = [:];
			m.acctid = acct.objid;
			m.year = it.year;
			m.month = it.month;
			m.txndate = txndate;
			m.amount = it.amount;
			m.amtpaid = 0;
			m.discount = 0;
			m.item = [objid: it.billcode];
			m.parentrefid = it.parentrefid;
			m.remarks = it.remarks;
			billItemEm.create( m );
		};
		billItemEm.find( [acctid: acct.objid, year: bill.period.year, month: bill.period.month ] ).update( [billid: bill.objid ]);
		def nextValidityDate = getNextValidityDate( bill.period, txndate );
		billEm.find( [objid: bill.objid]).update([validitydate: nextValidityDate]);

		//get credits and try to apply it.
		def creditAmt = creditEm.find( [acctid: acct.objid ] ).select("c:{SUM(dr-cr)}").where( "txndate <= :tdate", [tdate: txndate] ).val();
		if( creditAmt > 0 ) {
			def res2 = null;
			//if txndate is before the discount date, then it is possible there is a discount
			if( txndate.before( bill.period.discdate ) ) {
				res2 = ruleSvc.getPaymentItems( o );
				if( res2.amount < creditAmt ) {
					o.amtpaid = creditAmt;
					res2 = ruleSvc.getPaymentItems( o );
				}
			}
			else {
				o.amtpaid = creditAmt;
				res2 = ruleSvc.getPaymentItems( o );
			}	
			//post payments
			def rp = [:];
			rp.reftype = "waterworks_bill";
			rp.refno = bill.billno;
			rp.refid = bill.objid;
			rp.billitems = res.billitems;
			rp.amount = res.amount;
			pmtSvc.postPayment( rp );
		}
		//if validityate is still less than the txndate requested, run the update again.
		if( nextValidityDate < txndate ) {
			update( o );
		}
		else {
			if( nextValidityDate >= bill.period.billexpirydate ) {
				billEm.find( [objid: bill.objid ] ).update( [state: "CLOSED"] );		
			}
		}
	}

	//utilitties for this bill
	@ProxyMethod
	public def updateBalanceForward(  def b ) {
		if(! b.objid ) throw new Exception("objid of bill is required in WaterworksBillService.supdateBalanceForward");		
		def bill = vwBillEm.find( [objid: b.objid ]).first();		
		def p = [ ym: (bill.period.year*12)+bill.period.month ];
		//calculate balance forward
		def wh =  "((year*12)+month) < :ym AND ((amount-amtpaid-discount)>0)"
		def tot = billItemEm.find( [acctid: bill.acctid ] ).select("c:{SUM(amount-amtpaid-discount)}").where(wh, p).val();
		if(!tot) tot = 0;
		billEm.find([objid: bill.objid]).update([balanceforward: tot]);
		return tot;		
	}

	@ProxyMethod
	public def getBillDetails( def o ) {
		if(! b.objid ) throw new Exception("objid of bill is required in WaterworksBillService.getBillDetails");		
		
	}


	@ProxyMethod
	public def getBillTotals( def b ) {
		if(! b.objid ) throw new Exception("objid of bill is required in WaterworksBillService.getTotals");		
		def bill = billEm.select("balanceforward").find( [objid: b.objid ]).first();
		def m = [:];
		m.balanceforward = bill.balanceforward;
		return m;
	}


}