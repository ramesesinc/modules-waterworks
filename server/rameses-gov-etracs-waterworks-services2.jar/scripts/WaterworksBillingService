import com.rameses.annotations.*;
import com.rameses.functions.*;
import java.rmi.server.UID;
import com.rameses.util.*;
import treasury.utils.*;
import treasury.facts.*;
import waterworks.facts.*;
import com.rameses.annotations.*;
import com.rameses.util.*;


/****************************************************************************************
* This is for individual bills
*****************************************************************************************/
class WaterworksBillingService {
	
	@Service("WaterworksComputationService")
	def computeSvc;

	@Service("WaterworksBillingRuleService")
	def billingSvc;

	@DataContext('waterworks_billing')
	def billEm; 

	@DataContext('vw_waterworks_billing')
	def vwBillEm; 


	@DataContext('waterworks_account')
	def acctEm;


	@Service("WaterworksCreditPaymentService")
	def creditSvc;

	@DataContext('waterworks_otherfee')
	def otherFeeEm;

	@DataContext('waterworks_credit')
	def creditEm;

	/******************************************************
	* This is called from 
	*   1. batch billing persistence
	*   2. Generating statement from account
	*******************************************************/ 
	@ProxyMethod
	public def create(def p) {
		def wb = [:];
		wb.state = p.state;
		wb.batchid = p.batchid;
		wb.consumptionid = p.consumptionid;
		wb.billno = p.billno;			
		wb.objid = wb.billno;
		wb.discount = 0;
		wb.surcharge = 0;
		wb.interest = 0;
		wb.otherfees = 0;
		wb.credits = 0;
		wb.arrears = 0;
		wb.adjpayment = 0;
		wb.averageconsumption = 0;
		wb.unpaidmonths = 0;
		wb.billed = 0;
		wb.printed = 0;
		billEm.create( wb );	
		return wb;
	}
	

	@ProxyMethod
	public def process( o ) {
		//parameter should be the bill 

		//update first the otherfees billid for this year and month
		def bill = vwBillEm.find( [objid:  o.objid ] ).first();
		otherFeeEm.find( [acctid: bill.acctid] ).where( "year =:yr AND month = :mon", [yr: bill.year, mon: bill.month ] ).update( [billid: bill.objid ] );

		def u = [:];
		u.billed = 1;
		u.arrears = 0;
		u.surcharge = 0;
		u.interest = 0;
		u.adjpayment = 0;

		u.credits = creditEm.find( [acctid: bill.acctid] ).select("c:{SUM(dr-cr)}").val();
		if(u.credits == null) u.credits = 0;
		u.otherfees = otherFeeEm.find( [billid: bill.objid ] ).select( "c:{SUM(amount)}").val();
		if(u.otherfees==null) u.otherfees = 0;

		def pp = [ acctid : bill.acctid, billid: bill.objid ];
		//we need to get only the previous month otherwise it will include the latest reading included in the bill
		def ym = ((bill.year * 12) + bill.month)-1;
		pp.year = (int)(ym/12);
		pp.month = (int)(ym%12);

		def b = billingSvc.getBilling( pp ); 
		if( b?.billitems) {
			def arrears = b.billitems.findAll{ it.reftype == 'waterworks_consumption' }.sum{ it.amount  };
			def surcharge = b.billitems.findAll{it.surcharge}?.sum{ it.surcharge };
			def interest = b.billitems.findAll{it.interest}?.sum{ it.interest };
			def otherFees = b.billitems.findAll{ it.reftype == 'waterworks_otherfee' }?.sum{ it.amount };

			if( arrears ) u.arrears = arrears;
			if( surcharge ) u.surcharge = surcharge;
			if( interest ) u.interest = interest;
			if( otherFees ) u.otherfeearrears = otherFees;
		}

		//if there is no meter, run the computeSvc to get the volume and compute the consumption amount.
		if( !bill.meterid ) {
			computeSvc.compute([acctid:bill.acctid, consumptionid: bill.consumptionid, meterstate: bill.meterstate  ]);
		}
				
		billEm.find([ objid: bill.objid ]).update( u );
		return u;
	}

	@ProxyMethod
	public def approve( def o ) {
		def creditAmt = creditEm.find( [acctid: o.acctid] ).select("c:{SUM(dr-cr)}").val();
		if(creditAmt > 0 ) {
			creditSvc.postPayment( [acctid: o.acctid, billid: o.billid, amtpaid: creditAmt ] );
		}
		billEm.find([ objid: o.objid ]).update( [state:'POSTED'] );
	}

	
} 