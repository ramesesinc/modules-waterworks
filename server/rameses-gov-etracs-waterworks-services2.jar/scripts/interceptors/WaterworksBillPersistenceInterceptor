import com.rameses.annotations.*;
import java.rmi.server.*;

class WaterworksBillPersistenceInterceptor{
	
    @Service("ControlnoGeneratorService")
    def controlNoSvc;

   	@Service('Var')
	def var;	

	@Service("DateService")
	def dateSvc;

	@Service("WaterworksScheduleService")
	def skedSvc;

	@Service("WaterworksBillService")
	def billSvc;

	@DataContext("waterworks_account")
	def acctEm;

	@DataContext("vw_waterworks_account")
	def vwAcctEm;

	@DataContext("waterworks_credit")
	def creditEm;

	@DataContext("waterworks_payment")
	def paymentEm;

	@DataContext("waterworks_bill")
	def billEm;

	@DataContext("waterworks_billitem")
	def billItemEm;

	@DataContext("waterworks_consumption")
	def consumptionEm;



	@Before(pattern="PersistenceService.create", eval="#{args[0]._schemaname == 'waterworks_bill'}")
	public void beforeCreate(def evt) {
		def o  = evt.args[0];
		if(!o.acctid) throw new Exception("acctid is required");

		def acct = vwAcctEm.find( [objid: o.acctid ] ).first();

		//check first the bill year and month should not be greater than the group billing period
		if( !acct.subarea.period?.year ) throw new Exception("Please assign first billing period in subarea");
		def ym1 = (acct.subarea.period.year *12 ) + acct.subarea.period.month;
		def ym2 = (o.year*12)+o.month;
		if(ym2 > ym1) throw new Exception("Bill year and month must not be greater than the subarea billing period");

		if(!o.billno) o.billno = o.billrefno;

		if(!o.billno) {
			def pattern = var.waterworks_billno_format;
			if(!pattern) throw new Exception("Please specify waterworks_billno_format in sys_var");
			o.billno = controlNoSvc.getNextNo(pattern);
		};

		o.acctinfoid = acct.acctinfoid;
		o.period = skedSvc.getSchedule( [scheduleid: acct.subarea.schedulegroupid, year: o.year, month: o.month ]  );
		o.periodid = o.period.objid;
		o.billed = 0;
		o.printed = 0;
		o.billdate = o.period.billdate;
		o.expirydate = o.period.billexpirydate;
		o.state = "DRAFT";
		o.step = 1;
	}

	@After(pattern="PersistenceService.create", eval="#{args[0]._schemaname == 'waterworks_bill'}")
	public void afterCreate(def evt) {
		def o  = evt.args[0];
		def result = evt.result;
		acctEm.find( [objid: result.acctid ] ).update([ billid: result.objid ]);
		//update billitem if any
		billItemEm.updateInitialBillBalanceForward([acctid: result.acctid]);
	}

	//The only bill that can be deleted will be the initial bill
	@Before(pattern="PersistenceService.removeEntity", eval="#{args[0]._schemaname == 'waterworks_bill'}")
	public void beforeRemove(def evt) {
		def o  = evt.args[0];
		def bill = billEm.find([objid: o.objid]).first();
		if(bill.initial!=1) throw new Exception("Only the initial bill can be cancelled");

		//update first account and delete also credit payment if any.
		acctEm.find([billid: o.objid]).update([billid:"{NULL}"]);
		billEm.find( [objid: o.objid] ).update( [consumptionid: "{NULL}"]);
		consumptionEm.find( [billid: o.objid]).delete();
	}

	@After(pattern="PersistenceService.read", eval="#{args[0]._schemaname == 'vw_waterworks_bill'}")
	public void afterRead(def evt) {
		def bill  = evt.result;
		//check if there are still credits unapplied. Applicable to all bills initial or not
		def tot = 	billSvc.getBillTotals( [bill: bill] );
		bill.putAll( tot );
	} 


}