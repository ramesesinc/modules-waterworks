import com.rameses.annotations.*;

class WaterworksConsumptionPersistenceInterceptor{
	
	@DataContext("waterworks_consumption")
	def wcEm; 

	@DataContext("waterworks_account_info")
	def acctEm; 

	@DataContext("waterworks_meter")
	def meterEm; 

	@Before(pattern="PersistenceService.create", eval="#{args[0]._schemaname == 'waterworks_consumption'}")
	public void beforeCreate( evt ) { 
		def param = evt.args[0]; 
		param.hold = (param.hold ? param.hold : 0); 

		//check if reading is greater than capacity
		if( param.meterid ) {
			if(!param.reading ) throw new Exception("Please specify reading"); 
			def mtr = meterEm.find( [objid: param.meterid ] ).first();
			if( param.reading > mtr.capacity ) 
				throw new Exception("Meter reading must be less than capacity of " + mtr.capacity );
		}

		//check also the subarea 
		def v = acctEm.find( [objid: param.acctinfoid] ).select("subarea.nextperiod.*").first();
		def nextperiod = v.subarea.nextperiod;
		if( nextperiod?.year ) {
			int t = (nextperiod.year*12)+nextperiod.month;		
			if( ((param.year*12)+param.month) >= t )
				throw new Exception("Year and month entry should not be greater than the subarea next period");
		}
	} 

	@Before(pattern="PersistenceService.removeEntity", eval="#{args[0]._schemaname == 'waterworks_consumption'}")
	public void beforeRemove( evt ) {
		def param = evt.args[0];
		def findBy = (param?.findBy ? param.findBy : [objid: param.objid]); 
		def wc = wcEm.find( findBy ).first(); 
		if ( !wc ) return; 

		if ( wc.batchid ) 
			throw new Exception('Cannot delete consumption from batch billing'); 
		if( wc.state == 'POSTED' )	
			throw new Exception('Cannot delete consumption that is already posted'); 
		if ( wc.amtpaid > 0 )
			throw new Exception("Cannot delete consumption since payment was already made");
	} 

	

}