import com.rameses.annotations.*;

class WaterworksBillService {

	@Service("ControlnoGeneratorService")
    def controlNoSvc;

    @Service('Var')
	def var;

	@Service("WaterworksScheduleService")
	def skedSvc;

    @Service('DateService')
	def dateSvc;

	@Service("WaterworksBillingRuleService")
	def ruleSvc;

	@Service("WaterworksPaymentService")
	def pmtSvc;

	@DataContext("vw_waterworks_account")
	def vwAcctEm;

	@DataContext("vw_waterworks_bill")
	def vwBillEm;

	@DataContext("waterworks_bill")
	def billEm;

	@DataContext("waterworks_account")
	def acctEm;

	@DataContext("waterworks_billitem")
	def billItemEm;

	@DataContext("waterworks_payment")
	def pmtEm;

	@DataContext("waterworks_credit")
	def creditEm;

	@DataContext("waterworks_recurringfee")
	def recurFeeEm;

	@DataContext("waterworks_consumption")
	def consumptionEm;

	def getNextValidityDate(def period, def txndate ) {
		if(!txndate) txndate = dateSvc.getBasicServerDate();
		if( txndate.before( period.billdate ) ) {
			return period.billdate;	
		}
		else if( period.discdate && txndate.before(period.discdate )) {
			return period.discdate;		
		}
		else if( period.duedate && txndate.before(period.duedate)) {
			return period.duedate;
		}
		else {
			return period.billexpirydate;
		}
	}

	//utilities for this bill
	@ProxyMethod
	public def updateBalanceForward(  def b ) {
		if(! b.objid ) throw new Exception("objid of bill is required in WaterworksBillService.supdateBalanceForward");		
		def bill = vwBillEm.find( [objid: b.objid ]).first();		
		def p = [ ym: (bill.period.year*12)+bill.period.month ];
		//calculate balance forward
		def wh =  "((year*12)+month) < :ym AND ((amount-amtpaid)>0)"
		def tot = billItemEm.find( [acctid: bill.acctid ] ).select("c:{SUM(amount-amtpaid)}").where(wh, p).val();
		if(!tot) tot = 0;
		billEm.find([objid: bill.objid]).update([balanceforward: tot]);
		return tot;		
	}

	@ProxyMethod
	public def addConsumptionBill(def o) {
		if(! o.objid ) throw new Exception("objid of bill is required in WaterworksBillService.addConsumptionBill");	
		def cons = consumptionEm.find( [billid: o.objid ] ).first(); 
		if(!cons) throw new Exception("There is no consumption made yet for this bill");
		if(!cons.amount) throw new Exception("There is no amount computed yet for this consumption. Run calculate first in consumption");
		if(cons.hold == 1) throw new Exception("This consumption is on hold. Please check consumption first");

		def bill = vwBillEm.find( [objid: o.objid] ).first();
		def m = [:];
		m.acctid = bill.acctid;
		m.billid = bill.objid;
		m.item = [objid: "WATER_FEE"];
		m.amount = cons.amount;
		m.amtpaid = 0;
		m.discount = 0;
		m.year = bill.period.year;
		m.month = bill.period.month;
		m.txndate = bill.period.billdate;	
		m.system = 1;
		m.billed = 0;
		billItemEm.create( m );
	}

	@ProxyMethod
	public void updateBillFees( def o ) {
		if(! o.objid ) throw new Exception("objid of bill is required in WaterworksBillService.updateBillFees");
		def bill = vwBillEm.find( [objid: o.objid] ).first();

		def pp = [:];
		pp.account = vwAcctEm.find( [objid: bill.acctid ]).first();
		pp.bill = bill;
		pp.txndate = o.txndate;

		def res = ruleSvc.getBillItems( pp );
		//add item
		res.billitems.findAll{ it.objid == null }.each {
			def m = [:];
			m.acctid = bill.acctid;
			m.billid = bill.objid;
			m.item = [objid: it.billcode];
			m.amount = it.amount;
			m.amtpaid = 0;
			m.discount = 0;
			m.year = it.year;
			m.month = it.month;
			m.txndate = bill.period.billdate;	
			m.system = 0;
			m.billed = 0;
			m.particulars = it.remarks;
			m.recurringfeeid = it.recurringfeeid;
			billItemEm.create( m );
		}

		//also update amount billed for all waterworks_recurring. We will include billid so it will not update other recurring fees not included in bill
		recurFeeEm.updateAmtBilled( [acctid: bill.acctid, billid: bill.objid ] );
	}

	//this will automatically apply credits to open items of the previous and current bill. If return value is null, the credit was not applied. 
	//if successful, the new totals will be returned
	@ProxyMethod
	public void applyCredits( def o ) {
		if(! o.objid ) throw new Exception("objid of bill is required in WaterworksBillService.updateBillFees");
		
		def bill = vwBillEm.find( [objid: o.objid] ).first();
		def creditAmt = creditEm.find([acctid: bill.acctid]).select("c:{SUM(dr-cr)}").val();
		if(!creditAmt) return;

		//check if there are reminaing open items
		def amtdue = billItemEm.find( [acctid: bill.acctid] ).select("c:{SUM(amount-amtpaid-discount)}").where( "(amount-amtpaid-discount)>0" ).val();
		if( !amtdue ) return;

		def txndate = bill.billdate;
		if(!txndate) txndate = bill.period.billdate;
		if(!txndate) txndate = dateSvc.getBasicServerDate();

		def pp = [acctid: bill.acctid, amtpaid: creditAmt, billid: bill.objid, txndate:txndate, paymentreftype: "credit" ];
		def b = pmtSvc.getBillPaymentItems( pp );

		def cr = [:];
		cr.reftype = "credit";
		cr.refno = bill.billno;
		cr.refdate = txndate;		
		cr.acctid = bill.acctid;
		cr.billid = bill.objid;		
		cr.refno = bill.billno;
        cr.billitems = b.billitems;
        cr.amount = b.amount;
        pmtSvc.postPayment( cr );
	} 

	@ProxyMethod
	public def getBillTotals( def o ) {
		if(!o.bill && !o.objid ) throw new Exception("objid of bill is required in WaterworksBillService.getBalances");

		def bill = o.bill;
		if( !bill ) {
			bill =  vwBillEm.find( [objid: o.objid] ).first();
		}
		int ym1 = (bill.period.year*12)+bill.period.month;

		def v = [:];
		v.totalcredits = creditEm.find([acctid: bill.acctid]).select("c:{SUM(dr-cr)}").val();
		if(v.totalcredits == null ) v.totalcredits = 0;

		//total unpaid for previous
		v.totalprevunpaid = billItemEm.find([acctid: bill.acctid]).select("c:{SUM(amount-amtpaid-discount)}").where("(year*12)+month < :ym", [ym:ym1]).val(); 
		if(v.totalprevunpaid == null) v.totalprevunpaid = 0;

		//total unpaid amount for this bill
		v.totalbillunpaid = billItemEm.find([billid: bill.objid]).select("c:{SUM(amount-amtpaid-discount)}").val(); 
		if(v.totalbillunpaid == null) v.totalbillunpaid = 0;

		v.totalunpaid = v.totalprevunpaid + v.totalbillunpaid;

		//calculate also the total amt of sales and charges for this bill
		v.balanceforward = bill.balanceforward;

		v.billamount = billItemEm.find([billid: bill.objid]).select("c:{SUM(amount)}").val();
		if( v.billamount == null ) v.billamount = 0;

		//get total payments
		v.totalpayment = pmtEm.find([billid: bill.objid ]).where("reftype = 'cashreceipt' ").select("c:{SUM(amount)}").val();
		if(v.totalpayment == null) v.totalpayment = 0;

		v.totaldiscount = pmtEm.find([billid: bill.objid ]).select("c:{SUM(discount)}").val();
		if( v.totaldiscount == null ) v.totaldiscount = 0;

		v.totalamtdue = v.balanceforward + v.billamount - v.totalpayment - v.totaldiscount;

		return v;
	}

	@ProxyMethod
	public void approve(def o) {
		def bill = vwBillEm.find( [objid: o.objid] ).first(); 
		def t = getBillTotals([bill:bill]);
		if(t.billamount<=0) 
			throw new Exception("Bill amount must be greater than zero");
		if(t.unpaid>0 && t.totalcredits>0) 
			throw new Exception("All credits must be applied first");

		billEm.find( [objid: bill.objid ]).update( [state: "POSTED"] );
		if(bill.initial == 1) {
			acctEm.find( [objid: bill.acctid ]).update( [state:"ACTIVE"] ); 
		}
	}


}