import com.rameses.annotations.*;
import com.rameses.functions.*;
import java.rmi.server.UID;
import com.rameses.util.*;
import treasury.utils.*;
import treasury.facts.*;
import waterworks.facts.*;
import com.rameses.annotations.*;
import com.rameses.util.*;


/****************************************************************************************
* This is for individual bills
*****************************************************************************************/

class WaterworksBillProcessorService {
	
	@Service("WaterworksComputationService")
	def computeSvc;

	@Service("WaterworksBillingService")
	def billingSvc;

	@DataContext('waterworks_billing')
	def billEm; 

	@DataContext('vw_waterworks_consumption')
	def vwConsumptionEm; 

	@DataContext('waterworks_account')
	def acctEm;


	/******************************************************
	* This is called from 
	*   1. batch billing persistence
	*   2. Generating statement from account
	*******************************************************/ 
	@ProxyMethod
	public def create(def p) {
		def wb = [:];
		wb.state = p.state;
		wb.batchid = p.batchid;
		wb.consumptionid = p.consumptionid;			
		wb.billno = p.batchid + "-" + String.format("%04d", p.counter);
		wb.objid = wb.billno;
		wb.discount = 0;
		wb.surcharge = 0;
		wb.interest = 0;
		wb.otherfees = 0;
		wb.credits = 0;
		wb.arrears = 0;
		wb.adjpayment = 0;
		wb.averageconsumption = 0;
		wb.unpaidmonths = 0;
		wb.billed = 0;
		wb.printed = 0;
		billEm.create( wb );	
		return wb;
	}
	

	@ProxyMethod
	public def process( o ) {
		//parameters must be objid,acctid and consumptionid 

		def u = [:];
		u.billed = 1;
		u.arrears = 0;
		u.surcharge = 0;
		u.interest = 0;
		u.otherfees = 0;
		u.credits = 0;
		u.adjpayment = 0;

		def pp = [ acctid : o.acctid ];

		//we need to get only the previous month otherwise it will include the latest reading included in the bill
		if ( o.year && o.month ) {
			def ym = ((o.year * 12) + o.month)-1;
			pp.year = (int)(ym/12);
			pp.month = (int)(ym%12);
		}

		def b = billingSvc.getBilling( pp ); 
		if( b?.billitems) {
			def arrears = b.billitems.findAll{ it.reftype == 'waterworks_consumption' }.sum{ it.amount  };
			def surcharge = b.billitems.findAll{it.surcharge}?.sum{ it.surcharge };
			def interest = b.billitems.findAll{it.interest}?.sum{ it.interest };
			def otherFees = b.billitems.findAll{ it.reftype == 'waterworks_otherfee' }?.sum{ it.amount };
			def credits = b.billitems.findAll{ it.reftype == 'waterworks_credit' }?.sum{ it.amount };

			if( arrears ) u.arrears = arrears;
			if( surcharge ) u.surcharge = surcharge;
			if( interest ) u.interest = interest;
			if( otherFees ) u.otherfees = otherFees;
			if( credits ) {
				u.credits = credits * -1;
			}	
		}
		//update the waterworks_billing.
		//u.state = "FOR-READING";
		billEm.find([ objid: o.objid ]).update( u );

		//if there is no meter, run the computeSvc to get the volume and compute the consumption amount.
		if( !b.meterid && o.consumptionid ) {
			computeSvc.compute([acctid:o.acctid, consumptionid: o.consumptionid, meterstate: o.meterstate  ]);
		}
		return u;
	}


	


	
} 