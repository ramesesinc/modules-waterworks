import com.rameses.annotations.*;
import com.rameses.functions.*;
import java.rmi.server.UID;
import com.rameses.util.*;
import treasury.utils.*;
import treasury.facts.*;
import waterworks.facts.*;
import com.rameses.annotations.*;
import com.rameses.util.*;


/****************************************************************************************
* This is for individual bills
*****************************************************************************************/

class WaterworksBillProcessorService {
	
	@Service("WaterworksComputationService")
	def computeSvc;

	@Service("WaterworksBillingService")
	def billingSvc;

	@DataContext('waterworks_billing')
	def billEm; 

	@DataContext('vw_waterworks_consumption')
	def vwConsumptionEm; 

	@DataContext('waterworks_account')
	def acctEm;



	@ProxyMethod
	public int getErrCode(def v ) {
		def o = vwConsumptionEm.find([objid: v.consumptionid]).first();
		int errcode = 0;
		if( o.acctstate == "DRAFT" ) {
			errcode += 2;   //Account must not be in DRAFT mode;
		} 			
		if( o.meterid!=null && o.prevreading == null ){
			errcode += 4;   //There must be a previous month entry;
		};
		return errcode;
	}

	@ProxyMethod
	public def fixErrors(def o) {
		int errcode = getErrCode( o );
		def u = [:];
		u.errcode = errcode;
		if(errcode==0) u.state = "UNBILLED";
		billEm.find( [objid: o.objid] ).update( u );
		return u;
	}

	@ProxyMethod
	public def create( def o ) {
		if( !o.batchid ) throw new Exception("batchid is required");
		if( !o.consumptionid ) throw new Exception("consumptionid is required");
		if( !o.acctid ) throw new Exception("acctid is required");
		if( !o.counter ) throw new Exception("counter is required");

		int errcode = getErrCode( o );
		def wb = [:];
		wb.state = (errcode > 0) ? "ERR" : "UNBILLED";
		wb.batchid = o.batchid;
		wb.acctid = o.acctid;
		wb.consumptionid = o.consumptionid;			
		wb.billno = o.batchid + "-" + String.format("%04d", o.counter);
		wb.objid = wb.billno;
		wb.discount = 0;
		wb.surcharge = 0;
		wb.interest = 0;
		wb.otherfees = 0;
		wb.credits = 0;
		wb.arrears = 0;
		wb.averageconsumption = 0;
		wb.unpaidmonths = 0;
		wb.billed = 0;
		wb.printed = 0;
		wb.errcode = errcode;
		billEm.create( wb );
		return wb;
	}

	@ProxyMethod
	public void process( o ) {
		//parameters must be objid,acctid and consumptionid 
		def u = [:];
		u.billed = 1;
		u.arrears = 0;
		u.surcharge = 0;
		u.interest = 0;
		u.otherfees = 0;
		u.credits = 0;

		def pp = [ acctid : o.acctid, year: o.year, month: o.month ];
		/*
		if ( o.year && o.month ) {
			def ym = ((o.year * 12) + o.month)-1;
			pp.year = (int)(ym/12);
			pp.month = (int)(ym%12);
		}
		*/

		def b = billingSvc.getBilling( pp ); 
		if( b?.billitems) {
			def arrears = b.billitems.findAll{ it.reftype == 'waterworks_consumption' }.sum{ it.amount  };
			def surcharge = b.billitems.findAll{it.surcharge}?.sum{ it.surcharge };
			def interest = b.billitems.findAll{it.interest}?.sum{ it.interest };
			def otherFees = b.billitems.findAll{ it.reftype == 'waterworks_otherfee' }?.sum{ it.amount };
			def credits = b.billitems.findAll{ it.reftype == 'waterworks_credit' }?.sum{ it.amount };

			if( arrears ) u.arrears = arrears;
			if( surcharge ) u.surcharge = surcharge;
			if( interest ) u.interest = interest;
			if( otherFees ) u.otherfees = otherFees;
			if( credits ) {
				u.credits = credits * -1;
			}	
		}
		//update the waterworks_billing.
		u.state = "FOR-READING";
		billEm.find([ objid: o.objid ]).update( u );

		//if there is no meter, run the computeSvc to get the volume and compute the consumption amount.
		if( !b.meterid ) {
			computeSvc.compute([acctid:o.acctid, consumptionid: o.consumptionid, meterstate: o.meterstate  ]);
		}
	}


	


	
} 